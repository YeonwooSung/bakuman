# Kafka를 처음부터 다시 만들 수 있다면 어떨까?

[Kafka를 처음부터 다시 만들 수 있다면 어떨까?](https://news.hada.io/topic?id=20538)

# 클라우드 네이티브 이벤트 로그 시스템 설계: Kafka 재구상

클라우드 환경에 최적화된 이벤트 로그 시스템을 설계하기 위한 아이디어와 개념적 구조를 정리해보자.

## 핵심 아키텍처 설계

### 파티션 없는 키 중심 모델

```
메시지 → [키 인덱싱 계층] → [객체 스토리지(S3 등)]
         ↑                    ↑
         └─ 키별 인덱스 관리   └─ 무한 확장 스토리지
```

- **현재 Kafka**: 토픽은 N개의 파티션으로 분할되어 확장성 제한
- **새 설계**: 키를 중심으로 메시지 구성, 객체 스토리지 활용하여 스토리지 무한 확장
- **이점**: 
  - 사용자는 파티션을 고려할 필요 없음
  - 키별 메시지 접근 최적화
  - 엔티티/이벤트 소싱 패턴 지원 강화

### LSM 트리 기반 스토리지

클라우드 객체 스토리지와 LSM 트리 접근 방식을 결합:
- **핫 데이터**: 메모리 및 로컬 SSD에 저장
- **웜/콜드 데이터**: S3와 같은 객체 스토리지에 저장
- **효율적 인덱싱**: 키별 인덱스로 빠른 조회 지원

## 핵심 기능 구현

### 1. 동시성 제어

```
키별 낙관적 락 메커니즘:
메시지 {key: "user-123", value: "...", expectedVersion: 5}
```

- 각 키에 대해 버전 번호 추적
- 프로듀서는 `expectedVersion` 제공 가능
- 버전 불일치 시 브로커가 거부하고 오류 반환

### 2. 브로커 통합 스키마

```json
{
  "topic": "payments",
  "schema": {
    "type": "object",
    "properties": {
      "id": {"type": "string"},
      "amount": {"type": "number"},
      "status": {"type": "string", "enum": ["pending", "completed", "failed"]}
    }
  }
}
```

- 스키마 정의를 브로커에 직접 통합
- 메시지 생성/소비 시 자동 유효성 검증
- AsyncAPI와 같은 표준 메타데이터 지원

### 3. 토픽 계층 구조

```
구독 패턴: "orders/*/completed"
메시지 토픽: "orders/123/completed"
```

- 계층적 토픽 구조로 유연한 구독 패턴 지원
- 메시지 라우팅의 효율성 증가
- Solace PubSub+ 영감 구조 적용

### 4. 스냅샷 메커니즘

```
키 "user-123"의 이벤트 흐름:
[ev1] → [ev2] → [ev3] → [SNAPSHOT] → [ev4] → [ev5]
```

- 주기적으로 키별 상태 스냅샷 생성
- 소비자는 전체 이벤트 히스토리 대신 최근 스냅샷부터 소비 가능
- 재생 시간 대폭 단축

### 5. 플러그인 시스템

```
브로커 파이프라인:
[입력] → [인증 플러그인] → [변환 플러그인] → [저장 플러그인] → [출력]
```

- 인증/인가, 변환, 필터링을 위한 플러그인 아키텍처
- Iceberg 테이블 연동 플러그인 지원
- 속도 제한, 암호화 등 확장 기능

### 6. 멀티 테넌시

```
테넌트 A: 격리된 리소스, 네임스페이스, 접근 제어
테넌트 B: 격리된 리소스, 네임스페이스, 접근 제어
```

- 테넌트별 완전 리소스 격리
- 즉시 프로비저닝 가능한 테넌트 환경
- 자원 사용량 계측 및 과금 지원

## 기술적 개선사항

### 동기적 커밋 콜백

```
1. 프로듀서: 메시지 전송
2. 브로커: 저장 및 처리
3. 브로커 → 프로듀서: 확인 응답 (처리 결과 포함)
```

- 트랜잭션 완료 시점 명확히 파악 가능
- 자기 쓰기 읽기(read-your-own-writes) 보장
- 데이터베이스 로그로서의 기능 강화

이 설계는 현대적인 클라우드 환경에 최적화된 이벤트 로그 시스템을 구현하기 위한 개념적 청사진이다.
파티션 없는 키 중심 접근과 LSM 트리 아키텍처를 기반으로 확장성, 유연성, 개발자 친화성을 모두 달성할 수 있다.
